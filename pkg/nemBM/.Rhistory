network[clustering == i, clustering == j] <- if (BM[i, j] == "com")
matrix(1, nrow = size[i] * n, ncol = size[j] *  n)
else matrix(0, nrow = size[i] * n, ncol = size[j] * n)
}
}
diag(network) <- -1
initialNetwork <- network
if (symmetric == FALSE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- n.relocated * LE
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
diag(network) <- 0
return(network)
}
if (symmetric == TRUE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- (n.relocated * LE)/2
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
network[upper.tri(network)] = t(network)[upper.tri(network)]
diag(network) <- 0
return(network)
}
}
network <- genNetworkLE(BM = cohesiveBM, LE = 0.5, ize = c(5, 3, 2))
network <- genNetworkLE(BM = cohesiveBM, LE = 0.5, size = c(5, 3, 2))
genNetworkLE <- function (BM = BM, LE = 0.4, size = NULL, symmetric = FALSE) {
clustering <- rep(1:length(size), times = size)
network <- matrix(NA, nrow = sum(size), ncol = sum(size))
for (i in 1:nrow(BM)) {
for (j in 1:ncol(BM)) {
network[clustering == i, clustering == j] <- if (BM[i, j] == "com")
matrix(1, nrow = size[i] * n, ncol = size[j] *  n)
else matrix(0, nrow = size[i] * n, ncol = size[j] * n)
}
}
diag(network) <- -1
initialNetwork <- network
if (symmetric == FALSE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- n.relocated * LE
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
diag(network) <- 0
return(network)
}
if (symmetric == TRUE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- (n.relocated * LE)/2
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
network[upper.tri(network)] = t(network)[upper.tri(network)]
diag(network) <- 0
return(network)
}
}
cohesiveBM <- rbind(c("com", "nul"), c("nul", "com"))
network <- genNetworkLE(BM = cohesiveBM, LE = 0.5, size = c(5, 3, 2))
genNetworkLE <- function (BM = BM, LE = 0.4, size = NULL, symmetric = FALSE) {
clustering <- rep(1:length(size), times = size)
n <- sum(size)
network <- matrix(NA, nrow = n, ncol = n)
for (i in 1:nrow(BM)) {
for (j in 1:ncol(BM)) {
network[clustering == i, clustering == j] <- if (BM[i, j] == "com")
matrix(1, nrow = size[i] * n, ncol = size[j] *  n)
else matrix(0, nrow = size[i] * n, ncol = size[j] * n)
}
}
diag(network) <- -1
initialNetwork <- network
if (symmetric == FALSE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- n.relocated * LE
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
diag(network) <- 0
return(network)
}
if (symmetric == TRUE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- (n.relocated * LE)/2
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
network[upper.tri(network)] = t(network)[upper.tri(network)]
diag(network) <- 0
return(network)
}
}
cohesiveBM <- rbind(c("com", "nul"), c("nul", "com"))
network <- genNetworkLE(BM = cohesiveBM, LE = 0.5, size = c(5, 3, 2))
size = c(5, 3, 2)
clustering <- rep(1:length(size), times = size)
n <- sum(size)
n
network <- matrix(NA, nrow = n, ncol = n)
network
for (i in 1:nrow(BM)) {
for (j in 1:ncol(BM)) {
network[clustering == i, clustering == j] <- if (BM[i, j] == "com")
matrix(1, nrow = size[i] * n, ncol = size[j] *  n)
else matrix(0, nrow = size[i] * n, ncol = size[j] * n)
}
}
cohesiveBM
BM = cohesiveBM
for (i in 1:nrow(BM)) {
for (j in 1:ncol(BM)) {
network[clustering == i, clustering == j] <- if (BM[i, j] == "com")
matrix(1, nrow = size[i] * n, ncol = size[j] *  n)
else matrix(0, nrow = size[i] * n, ncol = size[j] * n)
}
}
i<-1
j<-1
network[clustering == i, clustering == j] <- if (BM[i, j] == "com")
clustering
BM[i, j]
genNetworkLE <- function (BM = BM, LE = 0.4, size = NULL, symmetric = FALSE) {
clustering <- rep(1:length(size), times = size)
n <- sum(size)
network <- matrix(NA, nrow = n, ncol = n)
for (i in 1:nrow(BM)) {
for (j in 1:ncol(BM)) {
network[clustering == i, clustering == j] <- if (BM[i, j] == "com") {
matrix(1, nrow = size[i], ncol = size[j])
} else {matrix(0, nrow = size[i], ncol = size[j])}
}
}
diag(network) <- -1
initialNetwork <- network
if (symmetric == FALSE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- n.relocated * LE
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
diag(network) <- 0
return(network)
}
if (symmetric == TRUE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- (n.relocated * LE)/2
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
network[upper.tri(network)] = t(network)[upper.tri(network)]
diag(network) <- 0
return(network)
}
}
cohesiveBM <- rbind(c("com", "nul"), c("nul", "com"))
network <- genNetworkLE(BM = cohesiveBM, LE = 0.5, size = c(5, 3, 2))
plotMat(network)
blockmodeling::plotMat(network)
network
cohesiveBM <- rbind(c("com", "nul"), c("nul", "com"))
network <- genNetworkLE(BM = cohesiveBM, LE = 0.5, size = c(5, 3))
genNetworkLE <- function (BM = BM, LE = 0.4, size = NULL, symmetric = FALSE) {
clustering <- rep(1:length(size), times = size)
n <- sum(size)
network <- matrix(NA, nrow = n, ncol = n)
for (i in 1:nrow(BM)) {
for (j in 1:ncol(BM)) {
network[clustering == i, clustering == j] <- if (BM[i, j] == "com") {
matrix(1, nrow = size[i], ncol = size[j])
} else {matrix(0, nrow = size[i], ncol = size[j])}
}
}
diag(network) <- -1
initialNetwork <- network
if (symmetric == FALSE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- n.relocated * LE
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
diag(network) <- 0
return(network)
}
if (symmetric == TRUE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- (n.relocated * LE)/2
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
network[upper.tri(network)] = t(network)[upper.tri(network)]
diag(network) <- 0
return(network)
}
}
network
devtools::document()
devtools::build_manual()
library(rcmdcheck)
devtools::document()
devtools::document()
devtools::document()
devtools::build_manual()
library(rcmdcheck)
library(rcmdcheck)
library(rcmdcheck)
devtools::build_manual()
devtools::document()
devtools::build_manual()
devtools::document()
devtools::build_manual()
devtools::document()
devtools::build_manual()
genNetworkLE <- function (BM = BM, LE = 0.4, size = NULL, symmetric = FALSE) {
clustering <- rep(1:length(size), times = size)
n <- sum(size)
network <- matrix(NA, nrow = n, ncol = n)
for (i in 1:nrow(BM)) {
for (j in 1:ncol(BM)) {
network[clustering == i, clustering == j] <- if (BM[i, j] == "com") {
matrix(1, nrow = size[i], ncol = size[j])
} else {matrix(0, nrow = size[i], ncol = size[j])}
}
}
diag(network) <- -1
initialNetwork <- network
if (symmetric == FALSE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- n.relocated * LE
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
diag(network) <- 0
return(network)
}
if (symmetric == TRUE) {
n.relocated <- sum(initialNetwork == 0, na.rm = TRUE) *
(sum(initialNetwork == 1, na.rm = TRUE)/(n * (n - 1)))
n.relocated.rs <- (n.relocated * LE)/2
p <- n.relocated.rs - floor(n.relocated.rs)
n.relocated.rs <- floor(n.relocated.rs) + stats::rbinom(1, 1, p)
remove.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 1), size = n.relocated.rs)
make.link <- sample(which(lower.tri(initialNetwork) & initialNetwork == 0), size = n.relocated.rs)
network[remove.link] <- 0
network[make.link] <- 1
network[upper.tri(network)] = t(network)[upper.tri(network)]
diag(network) <- 0
return(network)
}
}
cohesiveBM <- rbind(c("com", "nul"), c("nul", "com"))
ideal <- genNetworkLE(BM = cohesiveBM, LE = 0, n = 12, size = rep(0.5, 2))
ideal <- genNetworkLE(BM = cohesiveBM, LE = 0, n = 12, size = c(4, 4))
ideal <- genNetworkLE(BM = cohesiveBM, LE = 0, size = c(4, 4))
ideal
devtools::document()
library(rcmdcheck)
nemBM <- function(X = X,
partition,
M,
formula,
theta,
k = 10000,
loops = FALSE){
initial0 <- X
densityTarget <- globalDensity(M = M, partition = partition)
stevec <- 1
currentError <- SSEblock(X = X, M = M, partition = partition, loops = loops)
pogojZanka <- TRUE
n <- nrow(X)
netStatDF <- NULL
courseLinks <- data.frame("ego" = NA, "alterLink" = NA, "alterNonlink" = NA)
currentDensity <- mean(X)
timeElapsed <- system.time({
for (i in 1:k){
# izbor enot
actor <- sample(nrow(X), size = 1)
courseLinks[stevec, "ego"] <- actor
l.friends <- which(X[actor,] == 1)
nonfriends <- which(X[actor,] == 0)
q <- mean(M[partition[actor], `if`(loops, partition, partition[-actor])])
netStat <- WeightedNetworkStatistics(X = X, formula = formula, theta = theta, actor = actor, randomSD = 0.2)
# glede na gostote blokov
# (approach == "blockERR")
# blockCrit == "outdegree"
decision <- chooseBlockRow(X = X, partition = partition, actor = actor, M = M, loops = loops, randomBlock = "square")
if (decision["sign"] == 0) decision["sign"] <- sample(c(-1, 1), size = 1)
if (decision["sign"] > 0) {
naVoljo <- intersect(which(X[actor, ] == 1), which(partition == decision["block"]))
if (loops == FALSE) naVoljo <- naVoljo[naVoljo != actor]
if (length(naVoljo) > 0){
netStatRand <- netStat[naVoljo,]
alter <- as.numeric(sample(names(netStatRand[min(netStatRand) == netStatRand]), 1))
X[actor, alter] <- 0
}
}
if (decision["sign"] < 0) {
naVoljo <- intersect(which(X[actor, ] == 0), which(partition == decision["block"]))
if (loops == FALSE) naVoljo <- naVoljo[naVoljo != actor]
if (length(naVoljo) > 0){
netStatRand <- netStat[naVoljo,]
alter <- as.numeric(sample(names(netStatRand[max(netStatRand) == netStatRand]), 1))
X[actor, alter] <- 1
}
}
currentError[i] <- SSEblock(X = X, M = M, partition = partition, loops = loops)
currentDensity[i] <- mean(X)
}
})
return(list("initialNetwork" = initial0,
"finalNetwork" = X,
"formula" = formula,
"theta" = theta,
"ERR" = currentError,
"iterations" = k,
"loops" = loops,
"M" = M,
"partition" = partition,
"density" = currentDensity,
"timeElapsed" = timeElapsed))
}
formula <- list(mutuality, popularity, OTPtransitivity)
X <- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
diag(X) <- 0
M <- matrix(c(0.1, 0.8, 0.1, 0.5), nrow = 2)
partition <- c(1, 2, 2, 1, 1, 2, 2, 2, 1)
res <- nemBM(X = X, partition = partition, formula = formula,
theta = c(1, 1, 1), M = M, k = 100, loops = FALSE)
X
partition
initial0 <- X
densityTarget <- globalDensity(M = M, partition = partition)
stevec <- 1
currentError <- SSEblock(X = X, M = M, partition = partition, loops = loops)
pogojZanka <- TRUE
n <- nrow(X)
netStatDF <- NULL
courseLinks <- data.frame("ego" = NA, "alterLink" = NA, "alterNonlink" = NA)
currentDensity <- mean(X)
i<-1
# izbor enot
actor <- sample(nrow(X), size = 1)
courseLinks[stevec, "ego"] <- actor
l.friends <- which(X[actor,] == 1)
nonfriends <- which(X[actor,] == 0)
q <- mean(M[partition[actor], `if`(loops, partition, partition[-actor])])
netStat <- WeightedNetworkStatistics(X = X, formula = formula, theta = theta, actor = actor, randomSD = 0.2)
# glede na gostote blokov
# (approach == "blockERR")
# blockCrit == "outdegree"
decision <- chooseBlockRow(X = X, partition = partition, actor = actor, M = M, loops = loops, randomBlock = "square")
if (decision["sign"] == 0) decision["sign"] <- sample(c(-1, 1), size = 1)
if (decision["sign"] > 0) {
naVoljo <- intersect(which(X[actor, ] == 1), which(partition == decision["block"]))
if (loops == FALSE) naVoljo <- naVoljo[naVoljo != actor]
if (length(naVoljo) > 0){
netStatRand <- netStat[naVoljo,]
alter <- as.numeric(sample(names(netStatRand[min(netStatRand) == netStatRand]), 1))
X[actor, alter] <- 0
}
}
if (decision["sign"] < 0) {
naVoljo <- intersect(which(X[actor, ] == 0), which(partition == decision["block"]))
if (loops == FALSE) naVoljo <- naVoljo[naVoljo != actor]
if (length(naVoljo) > 0){
netStatRand <- netStat[naVoljo,]
alter <- as.numeric(sample(names(netStatRand[max(netStatRand) == netStatRand]), 1))
X[actor, alter] <- 1
}
}
decision["sign"]
decision["sign"] < 0
naVoljo <- intersect(which(X[actor, ] == 0), which(partition == decision["block"]))
if (loops == FALSE) naVoljo <- naVoljo[naVoljo != actor]
netStatRand <- netStat[naVoljo,]
alter <- as.numeric(sample(names(netStatRand[max(netStatRand) == netStatRand]), 1))
netStatRand
max(netStatRand) == netStatRand]
max(netStatRand) == netStatRand])
netStatRand
netStatRand[max(netStatRand) == netStatRand]
names(netStatRand[max(netStatRand) == netStatRand])
netStatRand
netStatRand
# glede na gostote blokov
# (approach == "blockERR")
# blockCrit == "outdegree"
decision <- chooseBlockRow(X = X, partition = partition, actor = actor, M = M, loops = loops, randomBlock = "square")
netStat
netStat <- WeightedNetworkStatistics(X = X, formula = formula, theta = theta, actor = actor, randomSD = 0.2)
netStat
netStat00 <- sapply(X = 1:length(formula), FUN = function(i){formula[[i]](X, actor = actor)})
netStat00
X
colnames(X)
if (is.null(colnames(X))) colnames(X) <- 1:ncol(X)
nemBM <- function(X = X,
partition,
M,
formula,
theta,
k = 10000,
loops = FALSE){
if (is.null(colnames(X))) colnames(X) <- 1:ncol(X)
if (is.null(rownames(X))) rownames(X) <- 1:ncol(X)
initial0 <- X
densityTarget <- globalDensity(M = M, partition = partition)
stevec <- 1
currentError <- SSEblock(X = X, M = M, partition = partition, loops = loops)
pogojZanka <- TRUE
n <- nrow(X)
netStatDF <- NULL
courseLinks <- data.frame("ego" = NA, "alterLink" = NA, "alterNonlink" = NA)
currentDensity <- mean(X)
timeElapsed <- system.time({
for (i in 1:k){
# izbor enot
actor <- sample(nrow(X), size = 1)
courseLinks[stevec, "ego"] <- actor
l.friends <- which(X[actor,] == 1)
nonfriends <- which(X[actor,] == 0)
q <- mean(M[partition[actor], `if`(loops, partition, partition[-actor])])
netStat <- WeightedNetworkStatistics(X = X, formula = formula, theta = theta, actor = actor, randomSD = 0.2)
# glede na gostote blokov
# (approach == "blockERR")
# blockCrit == "outdegree"
decision <- chooseBlockRow(X = X, partition = partition, actor = actor, M = M, loops = loops, randomBlock = "square")
if (decision["sign"] == 0) decision["sign"] <- sample(c(-1, 1), size = 1)
if (decision["sign"] > 0) {
naVoljo <- intersect(which(X[actor, ] == 1), which(partition == decision["block"]))
if (loops == FALSE) naVoljo <- naVoljo[naVoljo != actor]
if (length(naVoljo) > 0){
netStatRand <- netStat[naVoljo,]
alter <- as.numeric(sample(names(netStatRand[min(netStatRand) == netStatRand]), 1))
X[actor, alter] <- 0
}
}
if (decision["sign"] < 0) {
naVoljo <- intersect(which(X[actor, ] == 0), which(partition == decision["block"]))
if (loops == FALSE) naVoljo <- naVoljo[naVoljo != actor]
if (length(naVoljo) > 0){
netStatRand <- netStat[naVoljo,]
alter <- as.numeric(sample(names(netStatRand[max(netStatRand) == netStatRand]), 1))
X[actor, alter] <- 1
}
}
currentError[i] <- SSEblock(X = X, M = M, partition = partition, loops = loops)
currentDensity[i] <- mean(X)
}
})
return(list("initialNetwork" = initial0,
"finalNetwork" = X,
"formula" = formula,
"theta" = theta,
"ERR" = currentError,
"iterations" = k,
"loops" = loops,
"M" = M,
"partition" = partition,
"density" = currentDensity,
"timeElapsed" = timeElapsed))
}
res <- nemBM(X = X, partition = partition, formula = formula,
theta = c(1, 1, 1), M = M, k = 100, loops = FALSE)
devtools::document()
